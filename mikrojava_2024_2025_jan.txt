Dodatak A. Programski jezik MikroJava
Ovaj dodatak opisuje programski jezik MikroJava koji se koristi u praktičnom delu kursa programskih
prevodilaca (13E114PP1, 13S114PP1) na Elektrotehničkom fakultetu u Beogradu. Mikrojava je slična
Javi, ali je mnogo jednostavnija.

A.1 Opšte osobine jezika
‐ MikroJava program počinje ključnom rečju program i ima statička polja, statičke metode i unutrašnje
klase koje se mogu koristiti kao (korisnički) tipovi podataka.
‐ Glavna metoda MikroJava programa se uvek zove main(). Kada se poziva MikroJava
program izvršava se ta metoda.
‐ Postoje:
‐ Celobrojne, znakovne i logičke konstante (int, char, bool).
‐ Osnovni tipovi: int, bool, char (ASCII).
‐ Promenljive: globalne (statičke), lokalne, klasne (polja).
‐ Promenljive osnovnih tipova sadrže vrednosti.
‐ Strukturirani/referencijalni tipovi: jednodimenzionalni nizovi kao u Javi, unutrašnje klase sa
poljima i metodama i skupovi koji se isključivo sastoje od celih brojeva.
‐ Promenljive referencijalnih tipova predstavljaju reference (sadrže adrese koje se ne mogu menjati
eksplicitno).
‐ Statičke metode u programu.
‐ Statička polja klasa.
‐ Ne postoji garbage kolektor (alocirani objekti se samo dealociraju nakon kraja programa).
‐ Postoji nasleđivanje klasa i polimorfizam.
‐ Postoji redefinisanje metoda.
‐ Metode unutrašnjih klasa su vezane za instancu i imaju implicitni parametar this (referenca na
instancu klase za koju je pozvana metoda).
‐ Referenca “this“ se implicitno deklariše u metodama unutrašnjih klasa kao prvi formalni argument
tipa reference na klasu kojoj metoda pripada.
‐ Unutar metoda instance, ime polja odnosi se na polje instance trenutnog objekta, pod
pretpostavkom da polje nije skriveno parametrom metode. Ako je skriveno, možemo pristupiti polju
instance preko this.fieldName.
‐ Predeklarisane procedure su ord, chr, len, add.
‐ Metoda print ispisuje vrednosti svih osnovnih tipova i skupova.
‐ Od kontrolnih struktura postoji uslovno grananje (if-else) i petlja (do-while).
‐ U skupovima se nalaze jedinstveni brojevi. Pokušaj ubacivanja nekog broja koji se već nalazi u
skupu se ignoriše. Skup se inicijalizuje operatorom new, na isti način kao nizovi, pri čemu se tada
zadaje njegov kapacitet.
‐ Postoje interfejsi koje mogu imati podrazumevane implementacije metoda. Klasa koja implementira
neki interfejs mora implementirati sve metode koje interfejs propisuje, a za koje nema
podrazumevane implementacije.

Primer programa
program p
const int tableSize = 10;
set s1;
class Table {
int pos[], neg[], factor;
{
void setfactor(int factor) {this.factor = factor;}
void putp (int a, int idx) { this.pos[idx] = a; }
void putn (int a, int idx) { this.neg[idx] = a; }
int getp (int idx) { return pos[idx]; }
int getn (int idx) { return neg[idx]; }
}
}
Table val;
int rows, columns;
{
void f(char ch, int a, int arg)
int x;
{
x = arg;
}
void main() int x, i; char c; int arr[];
{
val = new Table();
val.setfactor(2);
s1 = new set[5];
s1.add(5); s1.add(10);
print(s1);
arr = new int[3];
i = 0;
do
arr[i] = i;
while ( i<3, i++);
i = 0;
do
print(arr[i]);
while ( i<3, i++);
val.pos = new int [tableSize];
val.neg = new int [tableSize];
read(x);
i = 0;
do{
val.putp(0, i);
val.putn(0, i);
} while (i < tableSize, i++);
f(c, x, i);
read(rows);
x=rows;
do{
if(x <= 0) break;
if (0 <= x && x < tableSize)
{
val.putp(val.getp(x)+1);
}
else if (‐tableSize < x && x < 0)
{
val.putn(val.getn(‐x)+1);
}
read(x);
}while();
}
}

A.2 Sintaksa
Program

= ʺprogramʺ ident {ConstDecl | VarDecl | ClassDecl | InterfaceDecl } ʺ{ʺ {MethodDecl}
ʺ}ʺ.
ConstDecl
= ʺconstʺ Type identʺ=ʺ(numConst | charConst | boolConst) {, ident ʺ=ʺ (numConst |
charConst | boolConst)} ʺ;ʺ.
VarDecl
= Type ident [ʺ[ʺ ʺ]ʺ] {ʺ,ʺ ident [ʺ[ʺ ʺ]ʺ]} ʺ;ʺ.
ClassDecl
= ʺclassʺ ident [ʺextendsʺ Type] ʺ{ʺ {VarDecl} [ʺ{ʺ {MethodDecl} ʺ}ʺ] ʺ}ʺ. * za C nivo
InterfaceDecl
= ʺinterfaceʺ ident ʺ{ʺ {MethodDecl | MethodSignature ʺ;ʺ } ʺ}ʺ. * za C nivo
MethodSignature
= (Type | ʺvoidʺ) ident ʺ(ʺ [FormPars] ʺ)ʺ.
MethodDecl
= MethodSignature {VarDecl} ʺ{ʺ {Statement} ʺ}ʺ.
FormPars
= Type ident [ʺ[ʺ ʺ]ʺ] {ʺ,ʺ Type ident [ʺ[ʺ ʺ]ʺ]}.
Type
= ident.
Statement
= DesignatorStatement ʺ;ʺ
| ʺifʺ ʺ(ʺ Condition ʺ)ʺ Statement [ʺelseʺ Statement]
| ʺbreakʺ ʺ;ʺ
| ʺcontinueʺ ʺ;ʺ
| ʺreturnʺ [Expr] ʺ;ʺ
| ʺreadʺ ʺ(ʺ Designator ʺ)ʺ ʺ;ʺ
| ʺprintʺ ʺ(ʺ Expr [ʺ,ʺ numConst] ʺ)ʺ ʺ;ʺ
| ʺdoʺ Statement ʺwhileʺ ʺ(ʺ [Condition [ʺ,ʺ DesignatorStatement]] ʺ)ʺ ʺ;ʺ * za B i C nivo
| ʺ{ʺ {Statement} ʺ}ʺ.
DesignatorStatement = Designator (Assignop Expr | ʺ(ʺ [ActPars] ʺ)ʺ | ʺ++ʺ | ʺ‐‐ʺ)
| Designator Assignop Designator Setop Designator.
ActPars
= Expr {ʺ,ʺ Expr}.
Condition
= CondTerm {ʺ||ʺ CondTerm}.
CondTerm
= CondFact {ʺ&&ʺ CondFact}.
CondFact
= Expr [Relop Expr].
Expr
= [ʺ-ʺ] Term {Addop Term}
| Designator ʺmapʺ Designator. * za B i C nivo
Term
= Factor {Mulop Factor}.
Factor
= Designator [ʺ(ʺ [ActPars] ʺ)ʺ]
| numConst
| charConst
| boolConst
| ʺnewʺ Type ( ʺ[ʺ Expr ʺ]ʺ | ʺ(ʺ [ActPars] ʺ)ʺ )
| ʺ(ʺ Expr ʺ)ʺ.
Designator
= ident {ʺ.ʺ ident | ʺ[ʺ Expr ʺ]ʺ}.
Label
= ident.
Assignop
= ʺ=ʺ.
Relop
= ʺ==ʺ | ʺ!=ʺ | ʺ>ʺ | ʺ>=ʺ | ʺ<ʺ | ʺ<=ʺ.
Addop
= ʺ+ʺ | ʺ‐ʺ.
Mulop
= ʺ*ʺ | ʺ/ʺ | ʺ%ʺ.
Setop
= ʺunionʺ.
Leksičke Strukture
Ključne reči:
Vrste tokena :

Operatori:
Komentari:

program, break, class, else, const, if, new, print, read, return, void,
extends, continue, union, do, while, map, interface
ident = letter {letter | digit | ʺ_ʺ}.
numConst = digit {digit}.
charConst = ʺʹʺ printableChar ʺʹʺ.
boolConst = (ʺtrueʺ | ʺfalseʺ).
+, ‐, *, /, %, ==, !=, >, >=, <, <=, &&, ||, =, ++, ‐‐, ;, :, zarez, ., (, ), [, ], {, }
// do kraja linije

A.3 Semantika
Svi pojmovi u ovom dokumentu, koji imaju definiciju, su podvučeni da bi se naglasilo njihovo posebno
značenje. Definicije tih pojmova su date u nastavku.
Tip reference
Nizovi i klase su tipa reference.
Tip konstante
‐ Tip celobrojne konstante (npr. 17) je int.
‐ Tip znakovne konstante (npr. ʹxʹ) je char.
‐ Tip logičke konstante (npr. true) je bool.
Ekvivalentni tipovi podataka
Dva tipa podataka su ekvivalentna
‐ ako imaju isto ime, ili
‐ ako su oba nizovi, a tipovi njihovih elemenata su ekvivalentni.
Kompatibilni tipova podataka
Dva tipa podataka su kompatibilna
‐ ako su ekvivalentni, ili
‐ ako je jedan od njih tip reference, a drugi je tipa null.
Kompatibilnost tipova podataka pri dodeli
Tip src je kompatibilan pri dodeli sa tipom dst
‐ ako su src i dst ekvivalentni,
‐ ako je dst tip reference, a src je tipa null.
‐ ako je dst referenca na osnovnu klasu, a src referenca na izvedenu klasu
Predeklarisana imena
int
tip svih celobrojnih vrednosti
char
tip svih znakovnih vrednosti
bool
logički tip
set
tip skupa celobrojnih vrednosti
null
null vrednost promenljive tipa klase ili (znakovnog) niza simbolički označava referencu koja
ne pokazuje ni na jedan podatak
eol - kraj reda karaktera (odgovara znaku ʹ\nʹ); print(eol) vrši prelazak u novi red
chr - standardna metoda; chr(i) vrši konverziju celobrojnog izraza i u karakter (char)
ord - standardna metoda; ord(ch) vrši konverziju karaktera ch u celobrojnu vrednost (int)
add – standardna metoda; add(a, b) dodaje celobrojni izraz b u skup a
addAll – standardna metoda; addAll(a, b) dodaje sve elemente celobrojnog niza b u skup a
Opseg važenja
Opseg važenja (scope) predstavlja tekstualni doseg metode ili klase. Prostire se od početka definicije
metode ili klase do zatvorene velike zagrade na kraju te definicije. Opseg važenja ne uključuje imena
koja su deklarisana u opsezima koji su leksički ugnježdeni unutar njega. U opsegu se “vide” imena
deklarisana unutar njega i svih njemu spoljašnjih opsega. Pretpostavka je da postoji veštački globalni
opseg (universe), za koji je glavni program lokalan i koji sadrži sva predeklarisana imena.
Deklaracija imena u unutrašnjem opsegu S sakriva deklaraciju istog imena u spoljašnjem opsegu.
Napomena
• Indirektna rekurzija nije dozvoljena i svako ime mora biti deklarisano pre prvog korišćenja.
• Predeklarisana imena (npr. int ili char) mogu biti redeklarisani u unutrašnjem opsegu (ali to nije
preporučljivo).

A.4 Kontekstni uslovi
Opšti kontekstni uslovi
• Svako ime u programu mora biti deklarisano pre prvog korišćenja.
• Ime ne sme biti deklarisano više puta unutar istog opsega.
• U programu mora postojati metoda sa imenom main. Ona mora biti deklarisana kao void metoda
bez argumenata.
Kontekstni uslovi za standardne metode
chr(e); e mora biti izraz tipa int.
ord(c); c mora biti tipa char.
len(a); a mora biti niz ili znakovni niz.
add(a, b); a mora biti skup, b mora biti
izraz tipa int.
addAll(a, b); a mora biti skup, b mora
biti niz celih brojeva.
Kontekstni uslovi za MikroJava smene
Program = ʺprogramʺ ident {ConstDecl | VarDecl | ClassDecl } ʺ{ʺ {MethodDecl} ʺ}ʺ.
ConstDecl = ʺconstʺ Type ident ʺ=ʺ (numConst | charConst | boolConst) ʺ;ʺ.
• Tip terminala numConst, charConst ili boolConst mora biti ekvivalentan tipu Type.
VarDecl = Type ident [ʺ[ʺ ʺ]ʺ] {ʺ,ʺ ident [ʺ[ʺ ʺ]ʺ]} ʺ;ʺ.
ClassDecl = ʺclassʺ ident [ʺextendsʺ Type] ʺ{ʺ {VarDecl} [ʺ{ʺ {MethodDecl} ʺ}ʺ] ʺ}ʺ.
• Tip Type prilikom izvođenja klase iz druge klase mora biti klasa ili interfejs glavnog programa.
• Ukoliko tip Type predstavlja interfejs klasa mora definisati sve metode koje interfejs propisuje, a za
koje nema podrazumevanu implementaciju,
MethodDecl = (Type | ʺvoidʺ) ident ʺ(ʺ [FormPars] ʺ)ʺ {VarDecl} ʺ{ʺ {Statement} ʺ}ʺ.
• Ako metoda nije tipa void, mora imati iskaz return unutar svog tela (uslov treba da se proverava u
vreme izvršavanja programa).
FormPars = Type ident [ʺ[ʺ ʺ]ʺ] {ʺ,ʺ Type ident [ʺ[ʺ ʺ]ʺ]}.
Type = ident.
• ident mora označavati tip podataka.
Statement = DesignatorStatement ʺ;ʺ.
DesignatorStatement = Designator Assignop Expr ʺ;ʺ.
• Designator mora označavati promenljivu, element niza ili polje unutar objekta.
• Tip neterminala Expr mora biti kompatibilan pri dodeli sa tipom neterminala Designator.
DesignatorStatement = Designator (ʺ++ʺ | ʺ‐‐ʺ) ʺ;ʺ.
• Designator mora označavati promenljivu, element niza ili polje objekta unutrašnje klase.
• Designator mora biti tipa int.

DesignatorStatement = Designator ʺ(ʺ [ActPars] ʺ)ʺ ʺ;ʺ.
• Designator mora označavati nestatičku metodu unutrašnje klase ili globalnu funkciju glavnog
programa.
DesignatorStatement = Designator Assignop Designator Setop Designator
• Svi Designator neterminali moraju označavati skup.
• Pretpostaviti da je Designator neterminal sa leve strane skup koji je inicijalizovan pre poziva
operacije dovoljno velikim kapacitetom da se operacija izvrši.
Statement = ʺbreakʺ.
• Iskaz break se može koristiti samo unutar do-while petlje. Prekida izvršavanje neposredno
okružujuće petlje.
Statement = ʺcontinueʺ.
• Iskaz continue se može koristiti samo unutar do-while petlje. Prekida tekuću iteraciju neposredno
okružujuće petlje.
Statement = ʺreadʺ ʺ(ʺ Designator ʺ)ʺ ʺ;ʺ.
• Designator mora označavati promenljivu, element niza ili polje unutar objekta.
• Designator mora biti tipa int, char ili bool.
Statement = ʺprintʺ ʺ(ʺ Expr [ʺ,ʺ numConst] ʺ)ʺ ʺ;ʺ.
• Expr mora biti tipa int, char, bool ili set. Pri ispisivanju skupa ispisuju se svi brojevi koji se nalaze u
njemu razdvojeni blanko znakom.
Statement = ʺreturnʺ [Expr] .
• Tip neterminala Expr mora biti ekvivalentan povratnom tipu tekuće metode/ globalne funkcije.
• Ako neterminal Expr nedostaje, tekuća metoda mora biti deklarisana kao void.
• Ne sme postojati izvan tela metoda, odnosno globalnih funkcija.
Statement = ʺifʺ ʺ(ʺ Condition ʺ)ʺ Statement [ʺelseʺ Statement].
• Naredba if – ukoliko je vrednost uslovnog izraza Condition true, izvršavaju se naredbe u if grani, u
suprotnom izvršavaju se naredbe u else grani, ako je navedena.
• Tip uslovnog izraza Condition mora biti bool.
Statement = ʺdoʺ Statement ʺwhileʺ ʺ(ʺ [Condition [ʺ,ʺ DesignatorStatement]] ʺ)ʺ ʺ;ʺ.
• Iskazi koji se nalaze između ključnih reči do i while se izvršavaju barem jednom, a nakon svake
iteracije
se proverava uslov Condition i ako je ispunjen izvršava se sledeća iteracija.
•
• Ukoliko je neterminal Condition izostavljen, implicitno je uslov za nastavak petlje ispunjen(true).
• Iskazi koji se nalaze posle nakon neterminala Condition i zareza se izvršavaju na kraju iteracije, ako
je uslov za nastavak petlje ispunjen.
ActPars = Expr {ʺ,ʺ Expr}.
• Broj formalnih i stvarnih argumenata metode ili konstruktora mora biti isti.
• Tip svakog stvarnog argumenta mora biti kompatibilan pri dodeli sa tipom svakog formalnog
argumenta na odgovarajućoj poziciji.
Condition = CondTerm {ʺ||ʺ CondTerm}.
CondTerm = CondFact {ʺ&&ʺ CondFact}.

CondFact = Expr Relop Expr.
• Tipovi oba izraza moraju biti kompatibilni.
• Uz promenljive tipa klase ili niza, od relacionih operatora, mogu se koristiti samo != i ==.
Expr = Term.
Expr = ʺ‐ʺ Term.
• Term mora biti tipa int.
Expr = Expr Addop Term.
• Expr i Term moraju biti tipa int. U svakom slučaju, tipovi za Expr i Term moraju biti kompatibilni.
Expr = Designator ʺmapʺ Designator.
• Designator sa leve strane ključne reči map mora predstavljati funkciju koja prima jedan parametar
tipa int i njena povratna vrednost je tipa int.
• Designator sa desne strane mora predstavljati niz celobrojnih vrednosti.
• Funkcija predstavljena levim neterminalom Designator se poziva za sve elemente niza
predstavljenim desnim neterminalom Designator. Dobijeni neterminal Expr predstavlja zbir povratnih
vrednosti svih izvršenih poziva funkcije.
Term = Factor.
Term = Term Mulop Factor.
• Term i Factor moraju biti tipa int.
Factor = Designator | numConst | charConst |boolConst | ʺ(ʺ Expr ʺ)ʺ.
Factor = Designator ʺ(ʺ [ActPars] ʺ)ʺ.
• Designator mora označavati nestatičku metodu unutrašnje klase ili globalnu funkciju glavnog
programa.
Factor = ʺnewʺ Type ʺ[ʺ Expr ʺ]ʺ.
• Tip neterminala Expr mora biti int.
• Ako je Type skup onda se pravi skup sa kapacitetom Expr, u svim ostalim situacijama se pravi niz
elemanata tipa Type veličine Expr.
Factor = ʺnewʺ Type ʺ(ʺ [ActPars] ʺ)ʺ.
• Neterminal Type mora da označava klasu (korisnički definisani tip).
Designator = Designator ʺ.ʺ ident .
• Tip neterminala Designator mora biti klasa (ident mora biti ili polje ili metoda objekta označenog
neterminalom Designator).
Designator = Designator ʺ[ʺ Expr ʺ]ʺ.
• Tip neterminala Designator mora biti niz.
• Tip neterminala Expr mora biti int.
Assignop = ʺ=ʺ.
Operator dodele vrednosti je desno asocijativan.
Relop = ʺ==ʺ | ʺ!=ʺ | ʺ>ʺ | ʺ>=ʺ | ʺ<ʺ | ʺ<=ʺ.

Addop = ʺ+ʺ | ʺ‐ʺ.
Operatori su levo asocijativni.
Mulop = ʺ*ʺ | ʺ/ʺ | ʺ%ʺ.
Operatori su levo asocijativni.
Setop = ʺunionʺ.

A.5 Implementaciona ograničenja
• Ne sme se koristiti više od 256 lokalnih promenljivih.
• Ne sme se koristiti više od 65536 globalnih promenljivih.
• Klasa ne sme imati više od 65536 polja.
• Izvorni kod programa ne sme biti veći od 8 KB.

7

Dodatak B. MikroJava VM
Ovaj dodatak opisuje arhitekturu MikroJava virtuelne mašine koja se koristi u praktičnom delu kursa
programskih prevodilaca (13E114PP1/13S114PP1) na Elektrotehničkom fakultetu u Beogradu.
MikroJava VM je slična Java VM, ali ima znatno manje instrukcija. Neke instrukcije su takođe
pojednostavljene. Dok kod Java VM punilac razrešava imena operanada iz skladišta konstanti
(constant pool), dotle MikroJava VM koristi fiksne adrese operanada. U instrukcijama Java bajt koda
kodirani su i tipovi njihovih operanada, tako da se može proveriti konzistentnost predmetnog fajla
(object file). Instrukcije MikroJava bajt koda ne kodiraju tipove operanada.

B.1 Organizacija memorije
MikroJava VM koristi sledeće memorijske oblasti:
code

data

heap

pstack

estack
esp

pc

ra
free

fp

dl

ExprStack

(niz reči)

sp
Code
(niz bajtova)

Code
StaticData

Heap

ProcStack

ExprStack

StaticData
(niz reči)

Heap
(niz reči)

ProcStack
(niz reči)

Ova oblast sadrži kod metoda. U registru pc se nalazi indeks instrukcije koja se trenutno
izvršava. Registar mainpc sadrži početnu adresu metode main().
U ovoj oblasti se nalaze (statički ili globalni) podaci glavnog programa (npr. klase koju
kompajliramo). To je u stvari niz promenljivih. Svaka promenljiva zauzima jednu reč (32
bita). Adrese promenljivih su indeksi pomenutog niza.
Ova oblast sadrži dinamički alocirane objekte i nizove. Blokovi u heap‐u se alociraju
sekvencijalno. free pokazuje na početak slobodnog dela heap‐a. Dinamički alocirana
memorija se oslobađa samo na kraju izvršenja programa. Ne postoji sakupljanje đubreta.
Svako polje unutar objekta zauzima jednu reč (32 bita). Nizovi čiji su elementi tipa char
su nizovi bajtova. Njihova dužina je umnožak broja 4. Pokazivači su bajt ofseti u heap‐u.
Objekti tipa niza počinju “nevidljivom” rečju koja sadrži dužinu niza.
U ovoj oblasti VM pravi aktivacione zapise pozvanih metoda. Svaki zapis predstavlja niz
lokalnih promenljivih, pri čemu svaka zauzima jednu reč (32 bita). Adrese promenljivih
su indeksi niza. ra je povratna adresa metode, dl je dinamička veza (pokazivač na
aktivacioni zapis pozivaoca metode). Novoalocirani zapis se inicijalizuje nulama.
Ova oblast se koristi za skladištenje operanada instrukcija. ExprStack je prazan posle
svake MikroJava instrukcije. Argumenti metoda se prosleđuju na stek izraza i kasnije
uklanjaju Enter instrukcijom pozvane metode. Ovaj stek izraza se takođe koristi za
prosleđivanje povratne vrednosti metode pozivaocu metode.

Svi podaci (globalne promenljive, lokalne promenljive, promenljive na heap‐u) se inicijalizuju null
vrednošću (0 za int, chr(0) za char, null za reference).

B.2 Skup instrukcija
U sledećim tabelama su navedene instrukcije MikroJava VM, zajedno sa njihovim kodovima i
ponašanjem. Treća kolona tabela prikazuje sadržaj ExprStack‐a pre i posle svake instrukcije, na primer
…, val, val
…, val
znači da opisana instrukcija uklanja dve reči sa ExprStack‐a i stavlja novu reč na njega. Operandi
instrukcija imaju sledeće značenje:
b je bajt
s je short int (16 bitova)
w je reč (32 bita).
Promenljive tipa char zauzimaju najniži bajt reči, a za manipulaciju tim promenljivim se koriste
instrukcije za rad sa rečima (npr. load, store). Niz čiji su elementi tipa char predstavlja niz bajtova i sa
njima se manipuliše posebnim instrukcijama.

Instrukcije za load i store lokalnih promenljivih
opcode

instr.

opds

ExprStack

značenje

1

load

b

…

Load

2..5

load_n

6

store

7..10

store_n

b

…, val

push(local[b]);

…
…, val

Load (n = 0..3)
push(local[n]);

…, val
…

Store
local[b] = pop();

…, val
…

Store (n = 0..3)
local[n] = pop();

Instrukcije za load i store globalnih promenljivih
11

getstatic s

…
…, val

Load statičke promenljive
push(data[s]);

12

putstatic s

…, val
…

Store statičke promenljive
data[s] = pop();

Instrukcije za load i store polja objekata
13

getfield

s

14

putfield s

…, adr
…, val

Load polja objekta
adr = pop()/4; push(heap[adr+s]);

…, adr, val
…

Store polja objekta
val = pop(); adr = pop()/4;
heap[adr+s] = val;

Instrukcije za load konstanti
15..20

…

const_n

…, val
21

const_m1

22

const

w

Load konstante (n = 0..5)
push(n)

…
…, ‐1

Load konstante ‐1
push(‐1)

…
…, val

Load konstante
push(w)

…, val1, val2
…, val1+val2

Sabiranje
push(pop() + pop());

Aritmetičke operacije
23

add

24

sub

…, val1, val2
…, val1‐val2

Oduzimanje
push(‐pop() + pop());

25

mul

…, val1, val2
…, val1*val2

Množenje
push(pop() * pop());

26

div

…, val1, val2
…, val1/val2

Deljenje
x = pop(); push(pop() / x);

27

rem

…, val1, val2
…, val1%val2

Ostatak pri celobrojnom deljenju
x = pop(); push(pop() % x);

28

neg

…, val
…, ‐ val

Promena predznaka
push(‐pop());

29

shl

…, val
…, val1

Aritmetičko pomeranje ulevo
x = pop(); push(pop() << x);

30

shr

…, val
…, val1

Aritmetičko pomeranje udesno
x = pop(); push(pop() >> x);

31

inc

b1, b2

…
…

Inkrementiranje
local[b1] = local[b1] + b2;

Pravljenje objekata
32

new

s

…
…, adr

Novi objekat
alocirati oblast od s bajtova;
inicijalizovati oblast nulama;
push(adr(oblast));

33

newarray b

…, n
…, adr

Novi niz
n = pop();
if (b==0)
alocirati niz sa n elemenata veličine
bajta;
else if (b==1)
alocirati niz sa n elemenata veličine reči;
inicijalizovati niz nulama;
push(adr(niz));

Pristup nizu
34

aload

…, adr, index
…, val

Load elementa niza (+ provera indeksa)
i = pop(); adr = pop()/4+1;
push(heap[adr+i]);

35

astore

…, adr, index, val
…

Store elementa niza (+ provera indeksa)
val = pop(); i = pop(); adr = pop()/4+1;
heap[adr+i] = val;

36

baload

…, adr, index
…, val

Load elementa niza bajtova (+ provera indeksa)
i = pop(); adr = pop()/4+1; x
= heap[adr+i/4]; push(byte
i%4 of x);

37

bastore

…, adr, index, val
…

Store elementa niza bajtova (+ provera indeksa)
val = pop(); i = pop(); adr = pop()/4+1;
x = heap[adr+i/4];
set byte i%4 in x;
heap[adr+i/4] = x;

38

arraylength

…, adr
…, len

Dohvatanje dužine niza
adr = pop();
push(heap[adr]);

Operacije na steku
39

pop

…, val
…

Skidanje elementa sa vrha steka
dummy = pop();

40

dup

…, val
…, val, val

Udvajanje elementa na vrhu steka
x = pop(); push(x); push(x);

41

dup2

…, v1, v2
…, v1, v2, v1, v2

Udvajanje prva dva elementa na vrhu steka
y = pop(); x = pop();
push(x); push(y); push(x); push(y);

Skokovi
Adresa skoka je relativna u odnosu na početak instrukcije skoka.
42

jmp

s

43..48

j<cond>

s

Bezuslovni skok
pc = pc + s;
…, val1, val2
…

Uslovni skok (eq, ne, lt, le, gt, ge)
y = pop(); x = pop();
if (x cond y) pc = pc + s;
11

Pozivi metoda (PUSH i POP se odnose na stek procedura)
49

call

50

return

s

Poziv metode
PUSH(pc+3); pc := pc + s;
Povratak iz metode
pc = POP();

51

enter b1, b2

Početak obrade metode
psize = b1; lsize = b2; // u rečima
PUSH(fp); fp = sp; sp = sp + lsize;
inicijalizovati akt. zapis
svim
nulama;
for (i=psize‐1; i>=0; i‐‐) local[i] = pop();

52

exit

Kraj obrade metode
sp = fp; fp = POP();

Ulaz/Izlaz
53

read

…
…, val

Operacija čitanja
readInt(x); push(x);
// cita sa standardnog ulaza

54

print

…, val, width
…

Operacija ispisa
width = pop(); writeInt(pop(), width);
// vrsi ispis na standardni izlaz

55

bread

…
…, val

Operacija čitanja bajta
readChar(ch); push(ch);

56

bprint

…, val, width
…

Operacija ispisa bajta
width = pop(); writeChar(pop(), width);

Ostalo
57

trap

b

Generiše run time grešku
zavisno od vrednosti b se ispisuje odgovarajuća
poruka o grešci;
prekid izvršavanja;

58

invokevirtual w1,w2,...,wn,wn+1 …, adr
…

Poziv virtuelne metode
ime metode ima n znakova;
ovi znakovi su deo same instrukcije, i nalaze
se u rečima w1,w2,...,wn;
reč wn+1 je jednaka -1 i označava kraj
instrukcije;
instrukcija prvo ukloni adr sa steka izraza;
adr je adresa u statičkoj zoni memorije gde
počinje tabela virtuelnih funkcija za klasu
objekta čija metoda je pozvana;
ako se ime metode u instrukciji pronađe u
tabeli virtuelnih funkcija, instrukcija vrši
skok na početak tela date metode.

Kombinovani operatori
59

dup_x1

..,val2, val1

…,val1, val2, val1

Umetanje kopije vršne vrednosti ispod druge
vrednosti sa vrha steka izraza.
vrednost sa vrha steka se kopira i ubacuje
ispod druge vrednosti sa vrha steka izraza.

60

dup_x2

val1, val2, val3

…,val3, val1, val2, val3
…

Umetanje kopije vršne vrednosti ispod
treće vrednosti sa vrha steka izraza.
vrednost sa vrha steka se kopira i
ubacuje ispod treće vrednosti sa
vrha steka izraza.

B.3 Format predmetnog fajla
2 bajta: ʺMJʺ
4 bajta: veličina koda u bajtovima
4 bajta: broj reči rezervisan za globalne
podatke
4 bajta: mainPC: adresa
metode main() relativna u
odnosu na početak code
oblasti
memorije
n
bajtova: code oblast (n =
veličina koda specificirana
u header‐u)

B.4 Runtime greške
1 Nedostaje return iskaz u telu funkcije.

